{-# LANGUAGE NamedFieldPuns    #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE QuasiQuotes       #-}

module LangGenerators.GoLang where

import           RIO
import           RIO.FilePath      (joinPath, splitDirectories, (<.>), (</>))
import           RIO.List          (lastMaybe, sortOn)
import qualified RIO.Map           as M
import           RIO.Partial       (fromJust)
import qualified RIO.Text          as T

import           Data.Char         (isUpper)
import qualified Data.Time         as DT
import           NeatInterpolation

import           Data.Hashable     (hash)

import qualified Common            as C

import qualified RIO.Set           as Set
import           Types

run :: [ModuleDef] -> InstallPath -> RootModule -> Camelizer -> RIO App ()
run mDefs installPath@(InstallPath installPath') rootModule@(RootModule root) camelizer = do
  case (root, mPath <$> mDefs) of
    (Nothing, h:t) | any (/= h) t  -> do
      logError "GoLang generator: \"root module\" parameter must be defined for packages installed in different directories"
      exitFailure
    _Ok -> pure ()
  nameMappers <- genMappers rootModule mDefs camelizer
  logInfo $ "Installing GoLang packages to " <> displayShow installPath' <> "..."
  C.createInstallPaths installPath mDefs transformPath
  mapM_ (genModule installPath nameMappers) mDefs

data Package
  = Package
  { pPath :: ![FilePath]
  , pName :: !T.Text
  , pRef  :: !T.Text
  } deriving(Eq, Ord, Show)

data NameMappers
  = NameMappers
  { getRoot          :: !(Maybe Text)
  , getPackage       :: !(Text -> Maybe Package)
  , enumNameMapper   :: !(Text -> (Text -> Text))
  , enumFldMapper    :: !(Text -> ((Text,Text) -> Text))
  , structNameMapper :: !(Text -> (Text -> Text))
  , structFldMapper  :: !(Text -> ((Text, Text) -> Text))
  }

genModule :: InstallPath ->
             NameMappers ->
             ModuleDef   ->
             RIO App ()
genModule
  (InstallPath installPath)
  nameMappers
  mDef = do
    logInfo . display $ "  Installing "<>T.pack inst<>"..."
    imports <- findImports
    writeFileUtf8 inst [untrimming|// this file is automatically generated.
  // !!! DO NOT EDIT !!!

  package ${package'}

  ${imports}
  ${enumDefs}
  ${structDefs}|]
  where
    inst =
      let (fName', fPath) = mPath mDef
          fName = T.unpack fName' <.> "go"
      in
      joinPath (installPath : fPath) </> fName

    findImports =
       case lefts imp of
         [] -> case (rights imp, getRoot nameMappers) of
                ([],_)         -> pure ""
                (_,Nothing) -> do
                   logError "GoLang generator: RootModule must be defined"
                   exitFailure
                (imp', Just root) -> pure . T.concat $ aux root <$> (Set.toList . Set.fromList $ imp')
         e  -> do
           logError $ display $
             T.concat ["GoLang generator: module `"
                      ,mName mDef
                      ,"` refers to modules "
                      ,T.pack (show e)
                      ," in the `main` package"
                      ]
           exitFailure
      where
        thisPkg = getPackage nameMappers $ mName mDef
        imp = [ case p of { Nothing -> Left mn; Just pkg -> Right pkg } |
                mn <- externalModules mDef,
                let p = getPackage nameMappers mn,
                p /= thisPkg ]
        aux root p = [untrimming|import ${name} "${path}"|]
          where
            name = pRef p
            path = T.pack $ joinPath $ T.unpack root : pPath p

    package' = maybe "main" pName (getPackage nameMappers $ mName mDef)

    enums' = sortOn eName $ enums mDef
    structs' = sortOn sName $ structs mDef

    mName' = mName mDef

    enumDefs = T.concat $
      enumDef nameMappers mName' <$> enums'
    structDefs = T.concat $
      structDef nameMappers mName' <$> structs'


enumDef :: NameMappers -> T.Text -> EnumDef -> T.Text
enumDef nameMappers mName' eDef = [untrimming|
  type ${eName'} string
  const (
    ${eFlds}
  )|]
  where
    eName' = eName eDef
    eFlds = mconcat $ f . fst <$> eValues eDef
    f v = [untrimming|${efn} ${eName'} = ${efv}|]
      where
        efn = enumFldMapper nameMappers mName' (eName',v)
        efv = goString v

structDef :: NameMappers -> T.Text -> StructDef -> T.Text
structDef nameMappers mName' sDef = [untrimming|
  type ${csn} struct {
     ${fldDefs}
  }|]
  where
    sn = sName sDef
    csn = structNameMapper nameMappers mName' sn
    fldDefs = mconcat $ f <$> sFields sDef
      where
        f (fn,Field { moduleName, typ, container }) = [untrimming|${sfn} ${styp} `json:"${fn}"`|]
          where
            sfn = T.map (\case; '-' -> '_'; ch -> ch) $ structFldMapper nameMappers mName' (sn, fn)
            styp = case container of
              Lst k    -> T.replicate k "[]"<>naked
              Opt      -> "*"<>naked
              OptLst k -> "*"<>T.replicate k "[]"<>naked
              Naked    -> naked
            naked = case typ of
              BoolS              -> "string"
              IntS               -> "string"
              DoubleS            -> "string"
              DollarS            -> "string"
              YearS              -> "string"
              PhoneS             -> "string"
              DateS              -> "string"
              PrimBool           -> "bool"
              PrimInt            -> "int"
              PrimDouble         -> "float64"
              PrimString         -> "string"
              Enum en _ _  -> case moduleName of
                Nothing -> enumNameMapper nameMappers mName' en
                Just mn -> case (getPackage nameMappers mName', getPackage nameMappers mn) of
                  (thisPkg, pkg) | thisPkg == pkg ->  enumNameMapper nameMappers mn en
                  (_, Nothing)       -> error "-- IMPOSSIBLE --"
                  (_, Just pkg)      -> pRef pkg<>"."<>enumNameMapper nameMappers mn en
              Struct stn         -> case moduleName of
                Nothing -> structFldMapper nameMappers mName' (sn,stn)
                Just mn -> case (getPackage nameMappers mName', getPackage nameMappers mn) of
                  (thisPkg, pkg) | thisPkg == pkg ->  structFldMapper nameMappers mn (sn,stn)
                  (_, Nothing)       -> error "-- IMPOSSIBLE --"
                  (_, Just pkg)      -> pRef pkg<>"."<>structFldMapper nameMappers mn (sn,stn)

genMappers :: RootModule -> [ModuleDef] -> Camelizer -> RIO App NameMappers
genMappers (RootModule rootModule) mDefs camelizer =

  case () of
    _ | (Right structNameMapper, Right enumNameMapper, Right enumFldMapper) <-
      (genStructNameMapper, genEnumNameMapper, genEnumFldMapper) ->
        pure $ NameMappers { getRoot
                           , getPackage
                           , enumNameMapper
                           , structNameMapper
                           , enumFldMapper
                           , structFldMapper = const $ C.capitalizeT . camelizer . sanitizer . snd
                           }
      | otherwise -> do
          case genStructNameMapper of
            Left conflicts -> displayStructNameConflicts conflicts
            _Ok            -> pure ()
          case genEnumNameMapper of
            Left conflicts -> displayEnumNameConflicts conflicts
            _Ok            -> pure ()
          case genEnumFldMapper of
            Left conflicts -> displayEnumFldConflicts conflicts
            _Ok            -> pure ()
          exitFailure

           where
             displayStructNameConflicts ::
               [(Maybe Package, [(T.Text, [(T.Text,T.Text)])])] ->
               RIO App ()
             displayStructNameConflicts = mapM_ $ \(p, c) -> do
               logError $ display $ "In package "<>maybe "ROOT" (T.pack . joinPath . pPath) p<>":"
               forM_ c $ \(s, m) ->
                 logError $ display $ "  struct "<>s<>" is defined in multiple modules: "<>T.pack (show (fst <$> m))

             displayEnumNameConflicts ::
               [(Maybe Package, [(T.Text, [(T.Text,T.Text)])])] ->
               RIO App ()
             displayEnumNameConflicts = mapM_ $ \(p, c) -> do
               logError $ display $ "In package "<>maybe "ROOT" (T.pack . joinPath . pPath) p<>":"
               forM_ c $ \(e, m) ->
                 logError $ display $ "  enum "<>e<>" is defined in multiple modules: "<>T.pack (show (fst <$> m))

             displayEnumFldConflicts ::
               [(Maybe Package, [(T.Text, [(T.Text,(T.Text, T.Text))])])] ->
               RIO App ()
             displayEnumFldConflicts =  mapM_ $ \(p, c) -> do
               logError $ display $ "In package "<>maybe "ROOT" (T.pack . joinPath . pPath) p<>":"
               forM_ c $ \(e, m) -> do
                 logError $ display $ "  conlicting enum field "<>e<>" definition:"
                 forM_ m $ \(m',(en,ef)) ->
                   logError $ display $ "    "<>en<>"."<>ef<>" in module "<>m'

  where

    (getRoot, rootPath) = case rootModule of
      Nothing -> (Nothing, [])
      Just r  -> case splitDirectories $ T.unpack r of
        (gr : rp) -> (Just (T.pack gr), rp)
        _ERR      -> error "-- IMPOSSIBLE --"

    getPackage :: T.Text -> Maybe Package
    getPackage =
      let m = M.fromList $ (mName &&& getPkg . mPath) <$> mDefs in
      \mn -> fromMaybe (error $ "can not find path to module `"<>T.unpack mn<>"`")
             (mn `M.lookup` m)
      where
        getPkg :: (Text, [FilePath]) -> Maybe Package
        getPkg (_,path)
          | [] <- path' = Nothing
          | Just p <- lastMaybe path' =
            Just $ Package { pPath = path'
                           , pRef = T.pack $ concat [p,"_",take 8 . drop 1 . show . hash $ path]
                           , pName = T.pack p
                           }
          | otherwise = error "-- IMPOSSIBLE --"
          where path' = rootPath <> path

    genEnumNameMapper :: Either
                         [(Maybe Package, [(T.Text,[(T.Text,T.Text)])])]
                         (T.Text -> (T.Text -> T.Text))
    genEnumNameMapper =
      let enumMap = [ (p, C.checkedUniqNames eNameGen pm) | (p, pm) <- M.assocs packMapper ] in
      if null . lefts $ snd <$> enumMap
      then
        let m = mconcat (M.toList <$> rights (snd <$> enumMap)) <&>
                (\((mName', eName'), v) -> (mName', [(eName',v)])) &
                M.fromListWith (<>) &
                M.map M.fromList &
                M.map (\mS -> fromJust . (`M.lookup` mS))
        in Right (\x -> fromMaybe (error $ "genEnumNameMapper: can not find module "<>T.unpack x) (x `M.lookup` m))
      else
        Left [ (p, fromLeft (error "* IMPOSSIBLE *") c) | (p, c) <- enumMap, isLeft c ]

      where
        packMapper = foldl' pMap M.empty mDefs
          where
            pMap pm mDef = foldl' (\pm' en ->
                                    M.insertWith (<>) (getPackage (mName mDef))
                                    [(mName mDef, en)]
                                    pm'
                                  )
                           pm
                           (eName <$> enums mDef)

    genEnumFldMapper :: Either
                        [(Maybe Package, [(T.Text,[(T.Text,(T.Text,T.Text))])])]
                        (T.Text -> (T.Text, T.Text) -> T.Text)
    genEnumFldMapper =
      let fldsMap = [ (p, C.checkedUniqNames eFldNameGen pm) | (p,pm) <- M.assocs packMapper ] in
      if null . lefts $ snd <$> fldsMap
      then
        let m = mconcat (M.toList <$> rights (snd <$> fldsMap)) <&>
                (\((mName', (eName', fName')), v) -> (mName', [((eName',fName'),v)])) &
                M.fromListWith (<>) &
                M.map M.fromList &
                M.map (\mE -> fromJust . (`M.lookup` mE))
        in Right $ fromJust . (`M.lookup` m)
      else
        Left [ (p, fromLeft (error "* IMPOSSIBLE *") c) | (p, c) <- fldsMap, isLeft c ]

      where
        packMapper = foldl' pMap M.empty mDefs
          where
            pMap pm mDef = foldl' (\pm' (en, ef) ->
                                    M.insertWith (<>) (getPackage (mName mDef))
                                    [(mName mDef, (en, ef))]
                                    pm'
                                  )
                           pm
                           (mconcat $ uncurry C.enPairing . (eName &&& (fst <$>) . eValues) <$> enums mDef)


    genStructNameMapper :: Either
                           [(Maybe Package, [(T.Text,[(T.Text,T.Text)])])]
                           (T.Text -> (T.Text -> T.Text))
    genStructNameMapper =
      let strctMap = [ (p, C.checkedUniqNames sNameGen pm) | (p, pm) <- M.assocs packMapper ] in
      if null . lefts $ snd <$> strctMap
      then
        let m = mconcat (M.toList <$> rights (snd <$> strctMap)) <&>
                (\((mName', sName'), v) -> (mName', [(sName',v)])) &
                M.fromListWith (<>) &
                M.map M.fromList &
                M.map (\mS -> fromJust . (`M.lookup` mS))
        in Right $ fromJust . (`M.lookup` m)
      else
        Left [ (p, fromLeft (error "* IMPOSSIBLE *") c) | (p, c) <- strctMap, isLeft c ]

      where
        packMapper = foldl' pMap M.empty mDefs
          where
            pMap pm mDef = foldl' (\pm' sn ->
                                    M.insertWith (<>) (getPackage (mName mDef))
                                    [(mName mDef, sn)]
                                    pm'
                                  )
                           pm
                           (sName <$> structs mDef)


    sNameGen :: (Text, Text) -> Text
    sNameGen = C.capitalizeT  . camelizer . snd

    eNameGen :: (Text, Text) -> Text
    eNameGen = C.capitalizeT  . camelizer . snd

    eFldNameGen :: (Text, (Text,Text)) -> Text
    eFldNameGen (mName', (eName', fName')) =
      let en = eNameGen (mName', eName')
          prefixCandidate = T.filter isUpper en
          prefix = case () of
            _ | T.null prefixCandidate -> T.toUpper $ T.take 1 en
              | otherwise              -> prefixCandidate
      in
      prefix<>"_"<>sanitize fName'

    sanitize = sanitizeEnumFld camelizer

goString :: T.Text -> T.Text
goString = T.cons '"' . flip T.snoc '"'

goShow :: Show a => a -> T.Text
goShow = goString . T.pack . show

goEmptyString :: T.Text
goEmptyString = "\"\""

goNull :: T.Text
goNull = "nil"

goDate :: DT.Day -> T.Text
goDate = goString . T.pack . DT.formatTime DT.defaultTimeLocale "%0m/%0d/%0Y"

sanitizeEnumFld :: Camelizer -> Text -> Text
sanitizeEnumFld camelizer ef =
  sanitizer $ (C.capitalizeT . camelizer) ef

sanitizer :: Text -> Text
sanitizer = T.map (\case
                      '-' -> '_'
                      '*' -> '_'
                      '!' -> '_'
                      c   -> c)

transformPath :: FilePath -> FilePath
transformPath = id

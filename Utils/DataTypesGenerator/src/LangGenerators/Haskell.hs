{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE QuasiQuotes    #-}

module LangGenerators.Haskell where

import           Import
import           RIO.FilePath       (joinPath, splitDirectories, (<.>), (</>))
import           RIO.List           (intercalate, sortOn)
import qualified RIO.Map            as M
import qualified RIO.Text           as T

import           Data.Char          (isDigit, isLower, isUpper)

import           NeatInterpolation

import qualified Common             as C
import qualified Data.Time.Calendar as DT

run :: [ModuleDef] -> InstallPath -> RootModule -> Camelizer -> RIO App ()
run mDefs installPath@(InstallPath installPath') rootModule@(RootModule rootModule') camelizer = do
  checkRootModule rootModule'
  logInfo $ "Installing Haskell modules to " <> displayShow installPath' <> "..."
  C.createInstallPaths installPath mDefs transformPath
  mapM_ (genModule installPath nameMappers) mDefs
  where
    nameMappers = genMappers rootModule mDefs camelizer

data NameMappers =
  NameMappers
  { mNameMapper      :: !(Text -> Text)
  , enumNameMapper   :: !(Text -> (Text -> Text))
  , enumFldMapper    :: !(Text -> ((Text,Text) -> Text))
  , structNameMapper :: !(Text -> (Text -> Text))
  , structFldMapper  :: !(Text -> ((Text,Text) -> Text))
  }

genModule :: InstallPath ->
             NameMappers ->
             ModuleDef   ->
             RIO App ()
genModule
  (InstallPath installPath)
  nameMappers
  mDef = do
    logInfo . display $ "  Installing "<>T.pack inst<>"..."
    writeFileUtf8 inst [untrimming|-- this file is automatically generated.
    -- !!! DO NOT EDIT !!!

    {-# OPTIONS_GHC -Wno-unused-imports -Wno-unused-top-binds -O0 #-}
    {-# LANGUAGE OverloadedStrings #-}
    {-# LANGUAGE TemplateHaskell #-}

    module ${mNameMapped}
      ( ${enumHeader}${structHeader}
      ) where

    import Prelude
    import qualified Data.Text as T
    import Lens.Micro.TH(makeLenses)
    import Data.Aeson
    import Data.Aeson.Types
    import Text.ParserCombinators.ReadPrec()
    import Text.Read(readEither)
    import Data.Default
    import qualified Data.Time as DT

    ${modDefs}

    ${enumDefs}

    ${structDefs}

    --------------
    -- Specials --
    --------------
    class FromJSON a => FromEmptyable a where
      fromEmptyable :: Value -> Parser (Maybe a)
      fromEmptyable t
        | String "" <- t = pure Nothing
        | String t' <- t = case eitherDecode' $ encode t' of
            Right a -> pure $ Just a
            Left  e -> fail $ "fromEmptyable: failed to parse `"<>T.unpack t'<>"`: "<>e
        | otherwise = fail $ "fromEmptyable: unexpected type of `"<>show t

    class ToJSON a => ToEmptyable a where
      toEmptyable :: Maybe a -> Value
      toEmptyable Nothing = String ""
      toEmptyable (Just a) = toJSON a

    instance FromEmptyable Bool where
      fromEmptyable t
        | String "" <- t      = pure Nothing
        | String "true" <- t  = pure $ Just True
        | String "false" <- t = pure $ Just False
        | otherwise = fail $ "fromEmptyable: failed to parse `"<>show t<>"` as BoolS"
    instance ToEmptyable Bool where
      toEmptyable Nothing = String ""
      toEmptyable (Just True) = String "true"
      toEmptyable (Just False) = String "false"


    instance FromEmptyable Int where
      fromEmptyable t
        | String "" <- t = pure Nothing
        | String t' <- t = case readEither $ T.unpack t' of
          Right i -> pure $ Just i
          Left  e -> fail $ "fromEmptyable: failed to parse `"<>T.unpack t'<>"`: "<>e
        | otherwise = fail $ "fromEmptyable: failed to parse `"<>show t<>"` as IntS"
    instance ToEmptyable Int where
      toEmptyable Nothing = String ""
      toEmptyable (Just a) = toJSON (show a)


    instance FromEmptyable Double where
      fromEmptyable t
        | String "" <- t = pure Nothing
        | String t' <- t = case readEither $ T.unpack t' of
          Right i -> pure $ Just i
          Left  e -> fail $ "fromEmptyable: failed to parse `"<>T.unpack t'<>"`: "<>e
        | otherwise = fail $ "fromEmptyable: failed to parse `"<>show t<>"` as DoubleS"
    instance ToEmptyable Double where
      toEmptyable Nothing = String ""
      toEmptyable (Just a) = toJSON (show a)

    instance FromEmptyable T.Text where
      fromEmptyable t
        | String "" <- t = pure Nothing
        | String t' <- t = pure $ Just t'
        | otherwise = fail $ "fromEmptyable: failed to parse `"<>show t<>"` as Text"
    instance ToEmptyable T.Text

    instance FromEmptyable DT.Day where
      fromEmptyable t
        | String "" <- t = pure Nothing
        | String t' <- t =
          Just <$> DT.parseTimeM False DT.defaultTimeLocale "%0m/%0d/%0Y" (T.unpack t')
        | otherwise = fail $ "fromEmptyable: failed to parse `"<>show t<>"` as DateS"
    instance ToEmptyable DT.Day where
      toEmptyable Nothing = String ""
      toEmptyable (Just a) = toJSON (DT.formatTime DT.defaultTimeLocale "%0m/%0d/%0Y" a)

    (.:.) :: FromEmptyable a => Object -> T.Text -> Parser (Maybe a)
    (.:.) = explicitParseField fromEmptyable

    ${enumEmptyables}

    ----------
    -- JSON --
    ----------
    ${enumJSONs}
    ${structJSONs}

    ------------
    -- Lenses --
    ------------
    ${structLenses}

    --------------
    -- Defaults --
    --------------
    ${enumDefaults}
    ${structDefaults}

    |]
  where
    inst =
      let (fName', fPath) = mPath mDef
          fName = (T.unpack fName' & C.capitalize) <.> "hs"
      in
      joinPath (installPath : fPath) </>  fName

    mNameMapped = mNameMapper nameMappers thisModuleName
    enumHeader = T.intercalate "\n, " ((<>"(..)") . thisEnumNameMapper . eName <$> enums')
    structHeader =
      (if null enums' then id else ("\n---\n, "<>)) sh
      where
        sh = mconcat $ intercalate ["\n---\n, "] $  mapIt <$> structs'
        mapIt s = csn<>"("<>csn<>")" : "\n, "<>lsn : (("\n, "<>) . thisStructFldMapper <$> flds)
         where
           sn = sName s
           csn  = thisStructNameMapper sn
           lsn  = "default"<>csn
           flds = C.enPairing sn $ fst <$> sFields s

    modDefs = T.intercalate "\n" $ ("import qualified "<>) . mNameMapper nameMappers <$> externalModules mDef
    enumDefs = mconcat $ (<>"\n") . enumDef nameMappers thisModuleName <$> enums'
    structDefs = mconcat $ (<>"\n") . structDef nameMappers thisModuleName <$> structs'

    enumJSONs = mconcat $ (<>"\n") . enumJSON nameMappers thisModuleName <$> enums'
    enumEmptyables = mconcat $ f . enumNameMapper nameMappers thisModuleName <$> [ eName e | e <- enums', eEmptyable e ]
      where
        f en = "instance FromEmptyable "<>en<>"\ninstance ToEmptyable "<>en<>"\n"

    structJSONs = mconcat $ (<>"\n") . structJSON nameMappers thisModuleName <$> structs'

    structLenses = mconcat $ (<>"\n") . mlen <$> structs'
      where
        mlen StructDef { sName } = "makeLenses ''"<>structNameMapper nameMappers thisModuleName sName

    enumDefaults = mconcat $ (<>"\n") . enumDefault nameMappers thisModuleName <$> [ e | e <- enums', not (eEmptyable e) ]
    structDefaults = mconcat $ (<>"\n") . structDefault nameMappers thisModuleName <$> structs'

    thisModuleName = mName mDef
    thisEnumNameMapper = enumNameMapper nameMappers thisModuleName
    thisStructNameMapper = structNameMapper nameMappers thisModuleName
    thisStructFldMapper = structFldMapper nameMappers thisModuleName

    enums' = sortOn (thisEnumNameMapper . eName) $ enums mDef
    structs' = sortOn (thisStructNameMapper . sName) $ structs mDef

enumDef :: NameMappers -> Text -> EnumDef -> Text
enumDef nameMappers thisModName eDef = [untrimming|
    data ${cen} =
      $def
         deriving(Eq,Ord,Show,Enum,Bounded)
    |]
  where
    en  = eName eDef
    cen = enumNameMapper nameMappers thisModName en
    def = T.intercalate "\n| " $
        enumFldMapper nameMappers thisModName <$>
        C.enPairing en (fst <$> eValues eDef)

structDef :: NameMappers -> Text -> StructDef -> Text
structDef nameMappers thisModName sDef = [untrimming|
    data ${csn} =
      ${csn}
        { ${def}
        } deriving(Eq,Ord,Show)
    |]
  where
    sn  = sName sDef
    csn = structNameMapper nameMappers thisModName sn
    def = T.intercalate "\n, " $ mapIt <$> sFields sDef
    mapIt fld = "_"<>structFldMapper nameMappers thisModName (sn, fst fld)<>" :: "<>mapT (snd fld)
    mapT Field { moduleName, typ, container} =
      case container of
         Lst n    -> T.replicate n "["<>naked<>T.replicate n "]"
         Opt      -> "Maybe "<>naked
         OptLst n -> "Maybe "<>T.replicate n "["<>naked<>T.replicate n "]"
         Naked    -> naked
      where
        naked = case typ of
          BoolS -> "Maybe Bool"
          IntS  -> "Maybe Int"
          DoubleS -> "Maybe Double"
          DollarS -> "Maybe Int"
          YearS -> "Maybe Int"
          PhoneS -> "Maybe T.Text"
          DateS -> "Maybe DT.Day"
          PrimBool -> "Bool"
          PrimInt -> "Int"
          PrimDouble -> "Double"
          PrimString -> "T.Text"
          Enum en eDflt _ ->
            (if isNothing eDflt then "Maybe " else "")<>
            case moduleName of
              Nothing -> enumNameMapper nameMappers thisModName en
              Just mn -> mNameMapper nameMappers mn<>"."<>enumNameMapper nameMappers mn en
          Struct stn ->
            case moduleName of
              Nothing -> structNameMapper nameMappers thisModName stn
              Just mn -> mNameMapper nameMappers mn<>"."<>structNameMapper nameMappers mn stn

enumJSON :: NameMappers -> Text -> EnumDef -> Text
enumJSON nameMappers thisModName eDef = [untrimming|
    instance FromJSON ${cen} where
      parseJSON = withText "${cen}" p
        where
          p :: T.Text -> Parser ${cen}
          p t = case t of
            ${defFrom}
            invalid ->
              fail ("parsing ${cen} failed: non-recognizable value: "<>T.unpack invalid)

    instance ToJSON ${cen} where
      toJSON t = case t of
        $defTo
      toEncoding t = case t of
        $defEnc
    |]
  where
    en  = eName eDef
    cen = enumNameMapper nameMappers thisModName en
    defFrom = mconcat $ fldFrom . fst <$> eValues eDef
    fldFrom v = [untrimming|"${v}" -> pure ${fv}|]
      where fv = enumFldMapper nameMappers thisModName (en,v)
    defTo = mconcat $ fldTo . fst <$> eValues eDef
    fldTo v = [untrimming|${fv} -> "${v}"|]
      where fv = enumFldMapper nameMappers thisModName (en,v)
    defEnc = mconcat $ fldEnc . fst <$> eValues eDef
    fldEnc v = [untrimming|${fv} -> toEncoding ("${v}" :: T.Text)|]
      where fv = enumFldMapper nameMappers thisModName (en,v)

structJSON :: NameMappers -> Text -> StructDef -> Text
structJSON nameMappers thisModName sDef = [untrimming|
    instance FromJSON ${csn} where
      parseJSON = withObject "${csn}" p
        where
          p :: Object -> Parser ${csn}
          p o = ${csn}
            <$> ${defFrom}

    instance ToJSON ${csn} where
      toJSON o = object
        [ ${defTo}
        ]
      toEncoding o = pairs
        (  ${defEnc}
        )
    |]
  where
    sn  = sName sDef
    csn = structNameMapper nameMappers thisModName sn
    defFrom = T.intercalate "<*> " $ fldFrom <$> sFields sDef
    fldFrom (n, Field { container, typ }) =
      case typ of
        BoolS   -> [untrimming|o .:. "${n}"|]
        IntS    -> [untrimming|o .:. "${n}"|]
        DoubleS -> [untrimming|o .:. "${n}"|]
        DollarS -> [untrimming|o .:. "${n}"|]
        YearS   -> [untrimming|o .:. "${n}"|]
        PhoneS  -> [untrimming|o .:. "${n}"|]
        DateS   -> [untrimming|o .:. "${n}"|]
        Enum _ Nothing _ ->
                   [untrimming|o .:. "${n}"|]
        _Else       ->
           case container of
             Opt       -> [untrimming|o .:?  "${n}"|]
             OptLst _  -> [untrimming|o .:?  "${n}"|]
             _Required -> [untrimming|o .:   "${n}"|]
    defTo  = T.intercalate ", " (flds False)
    defEnc = T.intercalate "<> " (flds True)
    flds omitEmpty = fld omitEmpty <$> sFields sDef
    fld omitEmpty (n, Field { container, typ }) =
      case typ of
        BoolS   -> [untrimming|"${n}" .= toEmptyable (_${fn} o)|]
        IntS    -> [untrimming|"${n}" .= toEmptyable (_${fn} o)|]
        DoubleS -> [untrimming|"${n}" .= toEmptyable (_${fn} o)|]
        DollarS -> [untrimming|"${n}" .= toEmptyable (_${fn} o)|]
        YearS   -> [untrimming|"${n}" .= toEmptyable (_${fn} o)|]
        PhoneS  -> [untrimming|"${n}" .= toEmptyable (_${fn} o)|]
        DateS   -> [untrimming|"${n}" .= toEmptyable (_${fn} o)|]
        Enum _ Nothing _ ->
                   [untrimming|"${n}" .= toEmptyable (_${fn} o)|]
        _ | omitEmpty ->
           case container of
             Opt       -> [untrimming|maybe mempty ("${n}" .=) (_${fn} o)|]
             OptLst _  -> [untrimming|maybe mempty ("${n}" .=) (_${fn} o)|]
             _Required -> [untrimming|"${n}" .= _${fn} o|]
        _Else -> [untrimming|"${n}" .= _${fn} o|]
      where fn = structFldMapper nameMappers thisModName (sn, n)

enumDefault :: NameMappers -> Text -> EnumDef -> Text
enumDefault nameMappers thisModName EnumDef { eName, eDflt } = [untrimming|
    instance Default ${cen} where
      def = ${dflt}
    |]
  where
    cen = enumNameMapper nameMappers thisModName eName
    dflt = case eDflt of
      Nothing     -> "Nothing"
      Just eDflt' -> enumFldMapper nameMappers thisModName (eName, eDflt')

structDefault :: NameMappers -> Text -> StructDef -> Text
structDefault nameMappers thisModName sDef = [untrimming|
    instance Default ${csn} where
      def = ${csn} ${defs}
    default${csn} :: ${csn}
    default${csn} = def
    |]
  where
    sn  = sName sDef
    csn = structNameMapper nameMappers thisModName sn
    defs = T.intercalate " " $ fld <$> sFields sDef
    fld (_, Field { moduleName, typ, container, dflt }) =
      if dflt == NoDflt
      then
        case (container,typ) of
          (Naked,PrimBool)   -> "False"
          (Naked,PrimString) -> "\"\""
          _Default           -> "def"
      else
        case (container, typ, dflt) of
          (Naked,BoolS,DfltB b)    -> "(Just "<>T.pack (show b)<>")"
          (Naked,IntS,DfltI i)     -> "(Just ("<>T.pack (show i)<>"))"
          (Naked,DoubleS,DfltD d)  -> "(Just ("<>T.pack (show d)<>"))"
          (Naked,DollarS,DfltI i)  -> "(Just ("<>T.pack (show i)<>"))"
          (Naked,YearS,DfltI i)    -> "(Just ("<>T.pack (show i)<>"))"
          (Naked,PhoneS,DfltS s)   -> "(Just ("<>T.pack (show s)<>"))"
          (Naked,DateS,DfltDate d) -> "(Just $ ModifiedJulianDay ("<>
             (T.pack . show $ DT.toModifiedJulianDay d)<>"))"
          (Naked,PrimBool,DfltB b) -> T.pack (show b)
          (Opt,PrimBool,DfltB b) -> "(Just "<>T.pack (show b)<>")"
          (Naked,PrimInt,DfltI i) -> "("<>T.pack (show i)<>")"
          (Opt,PrimInt,DfltI i) -> "(Just ("<>T.pack (show i)<>"))"
          (Naked,PrimDouble,DfltD d) -> "("<>T.pack (show d)<>")"
          (Opt,PrimDouble,DfltD d) -> "(Just ("<>T.pack (show d)<>"))"
          (Naked,PrimString,DfltS s) -> T.pack (show s)
          (Opt,PrimString,DfltS s) -> "(Just "<>T.pack (show s)<>")"
          (Naked,Enum e _ _,DfltS s) ->
             enumFldMapper nameMappers (fromMaybe thisModName moduleName) (e,s)
          (Opt,Enum e _ _,DfltS s) ->
             "(Just "<>enumFldMapper nameMappers (fromMaybe thisModName moduleName) (e,s)<>")"
          _ERR -> error $ "Wrong default: "<>show sDef<>" in module "<>show moduleName

genMappers :: RootModule -> [ModuleDef] -> Camelizer -> NameMappers
genMappers (RootModule rootModule) mDefs camelizer =
  NameMappers {
    mNameMapper = moduleNameMapper,
    enumNameMapper =
      let m = M.fromList $ (mName &&& eNameMapper) <$> mDefs in
      \mn -> fromMaybe (error "-- IMPOSSIBLE --") $ mn `M.lookup` m,
    structNameMapper =
      let m = M.fromList $ (mName &&& sNameMapper) <$> mDefs in
      \mn -> fromMaybe (error "-- IMPOSSIBLE --") $ mn `M.lookup` m,
    enumFldMapper =
      let m = M.fromList $ (mName &&& eFldMapper) <$> mDefs in
      \mn -> fromMaybe (error "-- IMPOSSIBLE --") $ mn `M.lookup` m,
    structFldMapper =
      let m = M.fromList $ (mName &&& sFldMapper) <$> mDefs in
      \mn -> fromMaybe (error "-- IMPOSSIBLE --") $ mn `M.lookup` m
    }
  where
    moduleNameMapper :: Text -> Text
    moduleNameMapper  =
      \mn -> fromMaybe (error "-- IMPOSSIBLE --") $ mn `M.lookup` m
      where
        m :: M.Map Text Text
        m = M.fromList $ (\md -> (mName md, genModuleName $ mPath md)) <$> mDefs

        genModuleName :: (Text, [FilePath]) -> Text
        genModuleName (mn,mp) =
          absM $
          T.intercalate "." ( (T.pack . C.capitalize <$> mp) <> [C.capitalizeT mn] )

        absM :: Text -> Text
        absM mn = maybe mn (<>"."<>mn) rootModule


    eNameMapper :: ModuleDef -> (Text -> Text)
    eNameMapper mDef =
      let m = M.fromList $ (eName &&& C.capitalizeT . camelizer . eName) <$> enums mDef in
      (\en -> fromMaybe (error $ "-- IMPOSSIBLE --`"<>T.unpack en<>"`") $ en `M.lookup` m)

    sNameMapper :: ModuleDef -> (Text -> Text)
    sNameMapper mDef =
      let m = M.fromList $ (sName &&& C.capitalizeT . camelizer . sName) <$> structs mDef in
      (\sn -> fromMaybe (error "-- IMPOSSIBLE --") $ sn `M.lookup` m)

    eFldMapper :: ModuleDef -> ((Text, Text) -> Text)
    eFldMapper mDef =
      let m = C.uniqNames (eShortNameGen mDef) (eLongNameGen mDef) $
              mconcat $
              uncurry C.enPairing . (eName &&& (fst <$>) . eValues)
              <$> enums mDef
      in (\e -> fromMaybe (error "-- IMPOSSIBLE --") $ e `M.lookup` m)

    sFldMapper :: ModuleDef -> ((Text, Text) -> Text)
    sFldMapper mDef =
      let m = C.uniqNames (sShortNameGen mDef) (sLongNameGen mDef) $
              mconcat $
              uncurry C.enPairing . (sName &&& fmap fst . sFields)
              <$> structs mDef
      in (\s -> fromMaybe (error "-- IMPOSSIBLE --") $ s `M.lookup` m)

    eShortNameGen :: ModuleDef -> (Text,Text) -> Text
    eShortNameGen mDef (eName', fName') =
      let
        en = eNameMapper mDef eName'
        prefixCandidate = T.filter isUpper en
        prefix = if T.null prefixCandidate
                 then T.take 1 prefixCandidate
                 else prefixCandidate
      in
      prefix<>"_"<>sanitize fName'

    eLongNameGen :: ModuleDef -> [(Text,Text)] -> [Text]
    eLongNameGen mDef =
      ((\(en,fName') -> en<>"_"<>sanitize fName') . first (eNameMapper mDef) <$>)


    sShortNameGen :: ModuleDef -> (Text,Text) -> Text
    sShortNameGen mDef (sName', fName') =
      let
        sn = sNameMapper mDef sName'
        prefixCandidate = T.filter isUpper sn
        prefix = if T.null prefixCandidate
                 then T.take 1 prefixCandidate
                 else prefixCandidate
      in
      T.toLower prefix <>(C.capitalizeT . camelizer) fName'

    sLongNameGen :: ModuleDef -> [(Text,Text)] -> [Text]
    sLongNameGen mDef =
      ((\(sn,fName') -> C.lowerizeT sn<>"_"<>(C.capitalizeT . camelizer) fName') .
       first (sNameMapper mDef) <$>)

    sanitize = sanitizeEnumFld camelizer

sanitizeEnumFld :: Camelizer -> Text -> Text
sanitizeEnumFld camelizer ef =
  T.map (\case
            '-' -> '_'
            '*' -> '_'
            '!' -> '_'
            c   -> c)
  $ (C.capitalizeT . camelizer) ef

checkRootModule :: Maybe Text -> RIO App ()
checkRootModule = \case
    Just rootM | not $ isValid rootM -> do
      logError $ "Invalid definition of RootModule ["<>display rootM<>"]"
      exitFailure
    _Ok -> pure ()
    where
      isValid s = all isValidSubModule $ T.split (== '.') s
      isValidSubModule m
        | Just (f,rest) <- T.uncons m, isUpper f, T.all isValidChar rest = True
        | otherwise                           = False
      isValidChar = flip any [isUpper,isLower,isDigit,(== '_')] . flip id

transformPath :: FilePath -> FilePath
transformPath fp = joinPath $ C.capitalize <$> splitDirectories fp

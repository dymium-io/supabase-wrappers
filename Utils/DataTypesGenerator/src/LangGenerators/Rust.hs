{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE QuasiQuotes    #-}

module LangGenerators.Rust where

import           RIO
import           RIO.FilePath
import           RIO.List          (intercalate, sort, sortOn)
import qualified RIO.Map           as M
import qualified RIO.Text          as T

import qualified Data.Time         as DT
import           NeatInterpolation

import           Types

import qualified Common            as C
import           RIO.Char          (isAlpha, isUpper, toUpper)
import qualified RIO.Set           as Set

run :: [ModuleDef] -> InstallPath -> RootModule -> Camelizer -> RIO App ()
run mDefs installPath@(InstallPath installPath') _rootModule camelizer = do
  logInfo $ "Installing Rust modules to " <> displayShow installPath' <> "..."
  C.createInstallPaths installPath mDefs transformPath
  nameMappers <- genMappers mDefs camelizer
  mapM_ (genModule installPath nameMappers) mDefs

data NameMappers =
  NameMappers
  { modulesPaths     :: !(Text -> (Text, [FilePath]))
  , mNameMapper      :: !(Text -> Text)
  , enumNameMapper   :: !(Text -> Text)
  , enumFldMapper    :: !((Text,Text) -> Text)
  , structNameMapper :: !(Text -> Text)
  , structFldMapper  :: !(Text -> Text)
  }

genModule :: InstallPath ->
             NameMappers ->
             ModuleDef   ->
             RIO App ()
genModule
  (InstallPath installPath)
  nameMappers
  mDef = do
    logInfo . display $ "  Installing "<>T.pack inst<>"..."
    -- logInfo . display . T.pack $ show mDef
    writeFileUtf8 inst [untrimming|// this file is automatically generated.
  // !!! DO NOT EDIT !!!

  use serde::{Serialize, Deserialize};

  ${imports}

  ${enumDefs}

  ${structDefs}


  |]
  where
    inst =
      let (fName', fPath) = mPath mDef
          fName = T.unpack fName' <.> "rs"
      in
      joinPath (installPath : fPath) </> fName

    imports = mconcat $ importString <$> externalModules mDef
      where
        importString em = T.concat ["use ",rPath,"::",em," as ",lName,";\n"]
          where
            lName = mNameMapper nameMappers  em
            rPath = T.pack $ "super::" <> intercalate "::"
                    (transform <$> C.calcRelativePath (snd $ mPath mDef) (snd $ modulesPaths nameMappers em))
            transform = \case
              ".." -> "super"
              p    -> p


    enums' = sortOn eName $ enums mDef
    structs' = sortOn sName $ structs mDef

    mName' = mName mDef

    enumDefs = T.intercalate "\n" $ enumDef nameMappers mName' <$> enums'
    structDefs = T.intercalate "\n" $ structDef nameMappers mName' <$> structs'

enumDef :: NameMappers -> T.Text -> EnumDef -> T.Text
enumDef nameMappers _mName' eDef = [untrimming|
  #[derive(Serialize, Deserialize, Debug)]
  pub enum ${eName'} {
    ${eFlds}
  }|]
  where
    eName' = eName eDef
    eFlds = mconcat $ f . fst <$> eValues eDef
    f v = [untrimming|#[serde(rename = "${v}")]
                      ${efn},|]
      where
        efn = enumFldMapper nameMappers (eName',v)

structDef :: NameMappers -> T.Text -> StructDef -> T.Text
structDef nameMappers _mName' sDef = [untrimming|
  #[derive(Serialize, Deserialize, Debug)]
  pub struct ${csn} {
    ${fldDefs}
  }|]
  where
    sn = sName sDef
    csn = structNameMapper nameMappers sn
    fldDefs = mconcat $ f <$> sFields sDef
      where
        f (fn,Field { moduleName, typ, container }) = [untrimming|pub ${sfn}: ${styp},|]
          where
            sfn = structFldMapper nameMappers fn
            styp = case container of
              Lst k -> T.replicate k "Vec<" <>naked <> T.replicate k ">"
              Opt   -> "Option<"<>naked<>">"
              OptLst k -> "Option<"<>T.replicate k "Vec<" <>naked <> T.replicate k ">"<>">"
              Naked -> naked
            naked = case typ of
              BoolS              -> "String"
              IntS               -> "String"
              DoubleS            -> "String"
              DollarS            -> "String"
              YearS              -> "String"
              PhoneS             -> "String"
              DateS              -> "String"
              PrimBool           -> "bool"
              PrimInt            -> "i64"
              PrimDouble         -> "f64"
              PrimString         -> "String"
              Enum en _ _  -> case moduleName of
                Nothing -> enumNameMapper nameMappers en
                Just mn -> mNameMapper nameMappers  mn<>"::"<>enumNameMapper nameMappers en
              Struct stn         -> case moduleName of
                Nothing -> structNameMapper nameMappers stn
                Just mn -> mNameMapper nameMappers  mn<>"::"<>structNameMapper nameMappers stn

genMappers :: [ModuleDef] -> Camelizer -> RIO App NameMappers
genMappers mDefs camelizer = do
  checkStructFldNames
  pure $ NameMappers
    { modulesPaths
    , mNameMapper = C.hashMapper mDefs
    , enumNameMapper
    , enumFldMapper
    , structNameMapper = camelizer
    , structFldMapper = sanitize
    }
  where

    checkStructFldNames :: RIO App ()
    checkStructFldNames = case () of
      _ | null conflictingFldDefs -> pure ()
        | otherwise -> do
        logError "Rust types generator error: field name is a Rust keyword:"
        forM_ (sort conflictingFldDefs) $
          \(mn, (sn, fn)) -> logError $ display $ T.concat ["  ",mn,".",sn,".",fn]
        exitFailure
      where
        conflictingFldDefs = [ (mName mDef,sn) | mDef <- mDefs
                                               , sn <- checkStruct (structs mDef) ]
        checkStruct sDefs = [ (sName sDef,fn) | sDef <- sDefs
                                              , fn <- checkField (sFields sDef) ]
        checkField fDefs = [ fn | (fn,_) <- fDefs, fn `Set.member` rustKeywords ]

    modulesPaths :: T.Text -> (T.Text, [FilePath])
    modulesPaths =
      let
        m = M.fromList $ (mName &&& mPath) <$> mDefs
      in
      \mn -> fromMaybe (error $ "can not find path to module `"<>T.unpack mn<>"`")
             (mn `M.lookup` m)

    enumNameMapper :: Text -> Text
    enumNameMapper = camelizer

    enumFldMapper :: (Text,Text) -> Text
    enumFldMapper (eName', fName') = capitalize . efm $ (sanitize . camelizer $ fName')
      where
        efm cfn
          | cfn `Set.member` rustKeywords = prefixize cfn
          | Just (c,_) <- T.uncons cfn, isAlpha c = cfn
          | otherwise = prefixize cfn
        prefixize cfn =
          let en = enumNameMapper eName'
              prefixCandidate = T.filter isUpper en
              prefix = case () of
                _ | T.null prefixCandidate -> T.toUpper $ T.take 1 en
                  | otherwise              -> prefixCandidate
          in prefix<>"_"<>cfn

capitalize :: T.Text -> T.Text
capitalize cfn
  | Just (c,_) <- T.uncons cfn, isUpper c = cfn
  | Just (c,t) <- T.uncons cfn = T.cons (toUpper c) t
  | otherwise = cfn

rustKeywords :: Set.Set Text
rustKeywords = Set.fromList [
  "as", "break", "const", "continue", "crate", "else", "enum", "extern",
  "false", "fn", "for", "if", "impl", "in", "let", "loop", "match", "mod",
  "move", "mut", "pub", "ref", "return", "self", "Self", "static",
  "struct", "super", "trait", "true", "type", "unsafe", "use", "where",
  "while", "sync", "await", "dyn", "abstract", "become", "box", "do",
  "final", "macro", "override", "priv", "typeof", "unsized", "virtual",
  "yield", "try"
  ]

rustString :: T.Text -> T.Text
rustString = T.cons '"' . flip T.snoc '"'

rustShow :: Show a => a -> T.Text
rustShow = rustString . T.pack . show

rustEmptyString :: T.Text
rustEmptyString = "\"\""

goNull :: T.Text
goNull = "null"

goDate :: DT.Day -> T.Text
goDate = rustString . T.pack . DT.formatTime DT.defaultTimeLocale "%0m/%0d/%0Y"

sanitize :: Text -> Text
sanitize =
  T.map (\case
            '-' -> '_'
            '*' -> '_'
            '!' -> '_'
            c   -> c)

transformPath :: FilePath -> FilePath
transformPath = id

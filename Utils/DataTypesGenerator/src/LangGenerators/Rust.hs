{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE QuasiQuotes    #-}

module LangGenerators.Rust where

import           RIO
import           RIO.Char          (isLower, isNumber, isUpper, toLower,
                                    toUpper)
import           RIO.FilePath
import           RIO.Lens          (each)
import           RIO.List          (intercalate, sort, sortOn)
import qualified RIO.Map           as M
import qualified RIO.Set           as Set
import qualified RIO.Text          as T

import qualified Data.Time         as DT
import           NeatInterpolation

import           Data.Tree

import           Types

import qualified Common            as C

run :: [ModuleDef] -> InstallPath -> RootModule -> Camelizer -> RIO App ()
run mDefs installPath@(InstallPath installPath') _rootModule camelizer = do
  logInfo $ "Installing Rust modules to " <> displayShow installPath' <> "..."
  C.createInstallPaths installPath mDefs transformPath
  defineMods installPath mDefs
  nameMappers <- genMappers mDefs camelizer
  mapM_ (genModule installPath nameMappers) mDefs

data NameMappers =
  NameMappers
  { modulesPaths     :: !(Text -> (Text, [FilePath]))
  , mNameMapper      :: !(Text -> Text)
  , enumNameMapper   :: !(Text -> Text)
  , enumFldMapper    :: !((Text,Text) -> Text)
  , structNameMapper :: !(Text -> Text)
  , structFldMapper  :: !(Text -> Text)
  }

genModule :: InstallPath ->
             NameMappers ->
             ModuleDef   ->
             RIO App ()
genModule
  (InstallPath installPath)
  nameMappers
  mDef = do
    logInfo . display $ "  Installing "<>T.pack inst<>"..."
    -- logInfo . display . T.pack $ show mDef
    writeFileUtf8 inst [untrimming|// this file is automatically generated.
  // !!! DO NOT EDIT !!!

  use serde::{Serialize, Deserialize};

  ${imports}

  ${enumDefs}

  ${structDefs}


  |]
  where
    inst =
      let (fName', fPath) = mPath mDef
          fName = snakeCase (T.unpack fName') <.> "rs"
      in
      joinPath (installPath : (fPath <&> snakeCase)) </> fName

    imports = mconcat $ importString <$> externalModules mDef
      where
        importString em = T.concat ["use ",rPath,"::",transformPathT em," as ",lName,";\n"]
          where
            lName = mNameMapper nameMappers  em
            rPath = T.pack $ "super::" <> intercalate "::"
                    (transform <$> C.calcRelativePath (snd $ mPath mDef) (snd $ modulesPaths nameMappers em))
            transform = \case
              ".." -> "super"
              p    -> transformPath p


    enums' = sortOn eName $ enums mDef
    structs' = sortOn sName $ structs mDef

    mName' = mName mDef

    enumDefs = T.intercalate "\n" $ enumDef nameMappers mName' <$> enums'
    structDefs = T.intercalate "\n" $ structDef nameMappers mName' <$> structs'

enumDef :: NameMappers -> T.Text -> EnumDef -> T.Text
enumDef nameMappers _mName' eDef = [untrimming|
  #[derive(Serialize, Deserialize, Debug)]
  pub enum ${eName'} {
    ${eFlds}
  }|]
  where
    eName' = eName eDef
    eFlds = mconcat $ f . fst <$> eValues eDef
    f v = [untrimming|#[serde(rename = "${v}")]
                      ${efn},|]
      where
        efn = enumFldMapper nameMappers (eName',v)

structDef :: NameMappers -> T.Text -> StructDef -> T.Text
structDef nameMappers _mName' sDef = [untrimming|
  #[derive(Serialize, Deserialize, Debug)]
  pub struct ${csn} {
    ${fldDefs}
  }|]
  where
    sn = sName sDef
    csn = structNameMapper nameMappers sn
    fldDefs = mconcat $ f <$> sFields sDef
      where
        f (fn,Field { moduleName, typ, container }) = [untrimming|#[serde(rename="${fn}")]
                                                       pub ${sfn}: ${styp},|]
          where
            sfn = structFldMapper nameMappers fn
            styp = case container of
              Lst k -> T.replicate k "Vec<" <>naked <> T.replicate k ">"
              Opt   -> "Option<"<>naked<>">"
              OptLst k -> "Option<"<>T.replicate k "Vec<" <>naked <> T.replicate k ">"<>">"
              Naked -> naked
            naked = case typ of
              BoolS              -> "String"
              IntS               -> "String"
              DoubleS            -> "String"
              DollarS            -> "String"
              YearS              -> "String"
              PhoneS             -> "String"
              DateS              -> "String"
              PrimBool           -> "bool"
              PrimInt            -> "i64"
              PrimDouble         -> "f64"
              PrimString         -> "String"
              Enum en _ _  -> case moduleName of
                Nothing -> enumNameMapper nameMappers en
                Just mn -> mNameMapper nameMappers  mn<>"::"<>enumNameMapper nameMappers en
              Struct stn         -> case moduleName of
                Nothing -> structNameMapper nameMappers stn
                Just mn -> mNameMapper nameMappers  mn<>"::"<>structNameMapper nameMappers stn

genMappers :: [ModuleDef] -> Camelizer -> RIO App NameMappers
genMappers mDefs _camelizer = do
  checkStructFldNames
  pure $ NameMappers
    { modulesPaths
    , mNameMapper = C.hashMapper mDefs
    , enumNameMapper = upperCamelCaseT
    , enumFldMapper = upperCamelCaseT . snd
    , structNameMapper = upperCamelCaseT
    , structFldMapper = sanitize . snakeCaseT
    }
  where

    checkStructFldNames :: RIO App ()
    checkStructFldNames = case () of
      _ | null conflictingFldDefs -> pure ()
        | otherwise -> do
        logError "Rust types generator error: field name is a Rust keyword:"
        forM_ (sort conflictingFldDefs) $
          \(mn, (sn, fn)) -> logError $ display $ T.concat ["  ",mn,".",sn,".",fn]
        exitFailure
      where
        conflictingFldDefs = [ (mName mDef,sn) | mDef <- mDefs
                                               , sn <- checkStruct (structs mDef) ]
        checkStruct sDefs = [ (sName sDef,fn) | sDef <- sDefs
                                              , fn <- checkField (sFields sDef) ]
        checkField fDefs = [ fn | (fn,_) <- fDefs, fn `Set.member` rustKeywords ]

    modulesPaths :: T.Text -> (T.Text, [FilePath])
    modulesPaths =
      let
        m = M.fromList $ (mName &&& mPath) <$> mDefs
      in
      \mn -> fromMaybe (error $ "can not find path to module `"<>T.unpack mn<>"`")
             (mn `M.lookup` m)

defineMods :: InstallPath -> [ModuleDef] -> RIO App ()
defineMods (InstallPath installPath) mDefs =
  forM_ mods (\(p, m) -> writeFileUtf8 p (T.concat ((\m' -> "pub mod "<>m'<>";\n") <$> m)))
  where
    mods :: [(FilePath,[Text])]
    mods = walkOver installPath pathsTree

    walkOver :: FilePath -> Tree FilePath -> [(FilePath,[Text])]
    walkOver fPath (Node rootLabel subForest) = case () of
      _ | null subForest -> []
        | rootLabel == "" ->
        (fPath</>"mod.rs", (\(Node r _) -> T.pack r) <$> subForest) : concat (walkOver fPath <$> subForest)
        | otherwise ->
        let fPath' = fPath </> rootLabel in
        (fPath'</>"mod.rs", (\(Node r _) -> T.pack r) <$> subForest) : concat (walkOver fPath' <$> subForest)

    pathsTree :: Tree FilePath
    pathsTree = foldl' insertIntoTree (Node "" []) paths
      where
        paths :: [[FilePath]]
        paths = (\(m,p) -> (transformPath <$> p)<>[transformPath . T.unpack $ m]) <$> mDefs ^..each .to mPath

    insertIntoTree :: Tree FilePath -> [FilePath] -> Tree FilePath
    insertIntoTree tree []             = tree
    insertIntoTree (Node n sub) (p:pp) = Node n $ insertIntoForest [] sub p pp

    insertIntoForest checked [] p pp = checked <> [toTree p pp]
    insertIntoForest checked (tree@(Node n _) : rest) p pp = case () of
      _ | n == p -> checked <> (insertIntoTree tree pp : rest)
        | otherwise -> insertIntoForest (checked <> [tree]) rest p pp

    toTree p []       = Node p []
    toTree p (p':pp') = Node p [toTree p' pp']

capitalize :: T.Text -> T.Text
capitalize cfn
  | Just (c,_) <- T.uncons cfn, isUpper c = cfn
  | Just (c,t) <- T.uncons cfn = T.cons (toUpper c) t
  | otherwise = cfn

rustKeywords :: Set.Set Text
rustKeywords = Set.fromList [
  "as", "break", "const", "continue", "crate", "else", "enum", "extern",
  "false", "fn", "for", "if", "impl", "in", "let", "loop", "match", "mod",
  "move", "mut", "pub", "ref", "return", "self", "Self", "static",
  "struct", "super", "trait", "true", "type", "unsafe", "use", "where",
  "while", "sync", "await", "dyn", "abstract", "become", "box", "do",
  "final", "macro", "override", "priv", "typeof", "unsized", "virtual",
  "yield", "try"
  ]

rustString :: T.Text -> T.Text
rustString = T.cons '"' . flip T.snoc '"'

rustShow :: Show a => a -> T.Text
rustShow = rustString . T.pack . show

rustEmptyString :: T.Text
rustEmptyString = "\"\""

goNull :: T.Text
goNull = "null"

goDate :: DT.Day -> T.Text
goDate = rustString . T.pack . DT.formatTime DT.defaultTimeLocale "%0m/%0d/%0Y"

sanitize :: Text -> Text
sanitize =
  T.map (\case
            '-' -> '_'
            '*' -> '_'
            '!' -> '_'
            c   -> c)

transformPath :: FilePath -> FilePath
transformPath = snakeCase

transformPathT :: Text -> Text
transformPathT = T.pack . transformPath . T.unpack

data State =
  Init
  | C1
  | CWord
  | Word

snakeCase :: String -> String
snakeCase = doIt Init
  where
    doIt _ [] = []
    doIt st (c:rest) = case () of
      _ | isUpper c -> case st of
          Init  -> toLower c : doIt C1 rest
          C1    -> toLower c : doIt CWord rest
          CWord -> toLower c : doIt CWord rest
          Word  -> '_' : toLower c : doIt Init rest
        | isLower c -> case st of
          Init  -> c : doIt Word rest
          C1    -> c : doIt Word rest
          CWord -> '_' : c : doIt Word rest
          Word  -> c : doIt Word rest
        | isNumber c -> case st of
          Init   -> c : doIt Word rest
          _Other -> c : doIt st rest
        | otherwise -> '_' : doIt Init rest

snakeCaseT :: Text -> Text
snakeCaseT = T.pack . snakeCase . T.unpack

upperCamelCase :: String -> String
upperCamelCase = doIt Init
  where
    doIt _ [] = []
    doIt st (c:rest) = case () of
      _ | isUpper c -> case st of
          Init   -> c : doIt CWord rest
          _Other -> c : doIt st rest
        | isLower c -> case st of
          Init  -> toUpper c : doIt C1 rest
          C1    -> c : doIt CWord rest
          CWord -> c : doIt CWord rest
          Word  -> c : doIt Word rest
        | isNumber c -> case st of
          Init   -> c : doIt Word rest
          _Other -> c : doIt st rest
        | otherwise -> doIt Init rest

upperCamelCaseT :: Text -> Text
upperCamelCaseT = T.pack . upperCamelCase . T.unpack
